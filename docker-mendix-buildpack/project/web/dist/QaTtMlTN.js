import{bl as vt,bm as Y,aK as bt,O as I,bn as ue,bo as Dt,bp as le,bq as de,br as nt,bs as xt,bt as gt,bu as he,bv as be,n as Ct,bw as z,bx as Gt,by as H,bz as ge,bA as me,bB as fe,bC as G,bD as Et,bE as _t,bF as Pt,bG as it,bH as Z,aP as tt,bI as St,bJ as ct,ad as et,bK as At,bL as pe,bM as ye,bN as we,bO as mt,bP as je,bQ as Oe,bR as Bt,bS as V,aC as at,bT as ve,bU as kt,bV as Ee,bW as Se,bX as Me,bY as K,bZ as $e,b_ as Te,b$ as De,c0 as xe,c1 as Rt,c2 as Lt,c3 as ot,c4 as ft,c5 as Ce,c6 as Ge,c7 as _e,c8 as pt,c9 as Pe,ca as Ft,aQ as Ae,cb as Be,cc as ke,cd as rt,ce as It,cf as Re,cg as Le,ch as Fe,ci as Ie,cj as Ut,ck as Ue,cl as Nt,cm as yt,cn as Ne,co as Je,cp as We,cq as Jt,cr as Wt,cs as ze,ct as qe,cu as He,cv as Ke,cw as zt,cx as qt,cy as Xe}from"./DTxgj959.js";const Ye=[n=>{const[t,e]=Ht(Y,{name:Dt,type:"text"});return n.inTransaction(async a=>{await a.exec(t,e);const s=(await a.selectObjects(`SELECT "${vt}" FROM "${Y}" WHERE "dirty" = ?`,[1])).map(i=>i[vt]),r=bt(),c=await async function(i,u,d){const[l,w]=Se(d),[O,b]=Me(We);await i.exec(l,w);const y=await i.selectObjects(O,b),p=parseInt(I(y[0])[ue],10);return Array.from({length:d},(v,S)=>{const T=Math.round(1e4*Math.random());return`${u}:${p-S}:${T}`})}(a,r.getSessionObjectId(),s.length);await Promise.all(s.map(async(i,u)=>a.exec(`UPDATE ${Y} SET ${Dt} = ? WHERE ${vt} = ?`,[I(c[u]),i])))})},n=>n.inTransaction(async t=>{const e=(await n.selectObjects("SELECT name FROM sqlite_master WHERE type='table' AND name NOT LIKE 'sqlite_%' AND name != 'android_metadata' AND name != ?",[le])).map(a=>a.name.toString()).filter(a=>!a.startsWith(de()));await Promise.all(e.map(a=>[t.exec(`DROP TABLE IF EXISTS ${nt(a)}`,[]).then(()=>t.exec(`ALTER TABLE ${a} RENAME TO ${nt(a)}`,[]))]))}),n=>{const[t,e]=Ht(nt(Y),{name:xt,type:"text"});return n.inTransaction(async a=>{await a.exec(t,e),await a.exec(`UPDATE ${nt(Y)} SET ${xt} = '[]'`)})}].map((n,t)=>({version:t+1,apply:n}));function Ht(n,t){return[`ALTER TABLE "${n}"
            ADD ${t.name} ${t.type} ${t.type==="text"?"COLLATE NOCASE":""}`,[]]}function ut([n,t]){return lt.inside((e,a,s)=>{e.executeSql(n,t,(r,c)=>{const i=[];for(let u=0;u<c.rows.length;u++)i.push(c.rows.item(u));a(i)},(r,c)=>(s(c),!0))})}class lt{constructor(){this.work=[]}chain(t){const e=new lt;return e.work.push(...this.work,{action:!1,item:t}),e}async read(t){return this.execute((e,a)=>t.readTransaction(e,a))}async write(t){return this.execute((e,a)=>t.transaction(e,a))}async execute(t){return new Promise((e,a)=>t(s=>{const r=Array.from(this.work);(function c(i){i instanceof lt&&(r.unshift(...i.work),i=void 0);const u=r.shift();if(!u)return void e(i);try{if(u.action)u.item(s,c,a);else{const d=u.item(i);c(d)}}catch(d){a(d)}})(s)},a))}static inside(t){const e=new lt;return e.work.push({action:!0,item:t}),e}}class Ve{constructor(t,e){this.database=t,this.webSqlDatabase=e}async apply(){(await ut(Jt(Y)).chain(t=>ut(Jt(nt(Y))).chain(e=>[...t,...e])).read(this.webSqlDatabase)).reduce((t,e)=>t+Object.values(e)[0],0)!==0&&await this.migrateSchemaAndDataFromWebSql()}async migrateSchemaAndDataFromWebSql(){const t=this.database.getLowLevelAPI(),e=await ut(["SELECT tbl_name, sql FROM sqlite_master WHERE type='table' AND tbl_name NOT LIKE '__WebKit%'",[]]).read(this.webSqlDatabase);await Promise.all(e.map(async a=>async function(s,r,c,i){await s.inTransaction(async u=>{await u.exec(i,[]);const d=await ut([`SELECT * FROM "${c}"`,[]]).read(r);await Promise.all(d.map(l=>u.exec(`INSERT OR IGNORE INTO "${c}" VALUES(${Object.keys(l).map(()=>"?").join(", ")})`,Object.values(l)))),await ut([`DROP TABLE "${c}"`,[]]).write(r)})}(t,this.webSqlDatabase,a.tbl_name,a.sql)))}}function st(n){return I(n?.attributes.changedDate).value??null}function J(n,t){return n.replace(/:/g,"_")+"@"+(t!=null&&t!==""?t.toString():"local")}function Mt(n,t,e){return e+J(t.map(n.guid),(st(n)??"").toString())}async function Kt(n,t,e,a,s){const r=a.reverse(),c=yt(o=>rt(o)),i=t.filter(o=>c(o.objectType)),u=Wt(o=>a.map(o.guid))(i),d={downloads:[],moves:[],deletes:[]},[l,w]=V(o=>o.guid in u,n);if(w.filter(o=>$(o)).forEach(o=>v(o)),!e){const o=Wt(h=>r.map(h.guid))(n);i.filter(h=>!(h.guid in o)).filter($).forEach(y)}const[O,b]=V(o=>ft(o.guid),l);return b.filter(o=>st(o)!==st(u[o.guid])).forEach(o=>{$(o)&&v(o),y(u[o.guid])}),O.filter(o=>{const h=u[o.guid];return $(o)&&$(h)&&st(o)!==st(h)}).forEach(o=>{if(e){const h=u[o.guid];(function(D,B,P=!0){const L=T(D,!1),g=T(B,!1);if(d.moves.push([L,g,D.guid]),P&&Z(D.objectType)){const M=T(D,!0),j=T(B,!0);d.moves.push([M,j,D.guid])}})(o,h,!1),Z(o.objectType)&&p(h)}else v(o),y(u[o.guid])}),O.filter(o=>$(o)&&!$(u[o.guid])).forEach(o=>v(o)),O.filter(o=>!$(o)&&$(u[o.guid])).forEach(o=>y(u[o.guid])),d;function y(o){const h=E(o,!1);d.downloads.push([S(o,!1),h,o.guid]),d.moves.push([h,T(o,!1),o.guid]),Z(o.objectType)&&p(o)}function p(o){const h=E(o,!0);d.downloads.push([S(o,!0),h,o.guid]),d.moves.push([h,T(o,!0),o.guid])}function v(o){const h=T(o,!1);d.deletes.push(h),Z(o.objectType)&&d.deletes.push(T(o,!0))}function S(o,h){return Nt(o.guid,st(o),h)}function T(o,h){return Mt(o,r,s.toAbsolutePath((h?"thumbnails":"documents")+"/"))}function E(o,h){return T(o,h)+"_tmp"}function $(o){return I(o.attributes.HasContents).value===!0}}async function q({downloads:n,moves:t,deletes:e},a,s){const r=new z;if(n!==void 0&&(s?.trace(`Downloading ${n.length} file documents.`),r.reset(),await Promise.all(n.map(([c,i])=>a.downloadFile(c,i))),s?.trace(`Downloaded ${n.length} file documents in ${r.measure()} milliseconds.`)),t!==void 0&&(s?.trace(`Moving ${t.length} file objects.`),r.reset(),await Promise.all(t.map(([c,i])=>a.moveFile(c,i))),s?.trace(`Moved ${t.length} file objects in ${r.measure()} milliseconds.`)),e!==void 0){let c=0;s?.trace(`Attempting to delete ${e.length} file objects.`),r.reset(),await Promise.all(e.map(async i=>{try{await a.removeFile(i)}catch(u){if(u instanceof DOMException&&u.name==="NotFoundError")return++c,void s?.trace(u.message);throw u}})),s?.trace(`Deleted ${e.length-c} file objects in ${r.measure()} milliseconds.`)}}async function Qe(n,t){const e="documents/"+J(t.guid,I(t.attributes.changedDate).value),a=await n.readFile(n.toAbsolutePath(e));return{tempGuid:(await async function(s,r,c,i){for(let u=0;u<=i;u++)try{return await ze(s,r,{},c,{},[])}catch(d){if(!(u<i))throw d;{const l=Math.pow(2,u);await qe(l)}}throw new et}("__sync__","",a,2)).commits[0],fileObjGuid:t.guid}}async function Xt(n,t,e){const a=[];for(let s=0;s<n.length;s+=4){const r=n.slice(s,s+4);await Promise.all(r.map(async([c,i,u])=>{try{await t.downloadFile(c,i)}catch(d){if(d instanceof He)throw e.trace(`Could not download file content for object ${u} due to a connection errorSynchronization will be aborted`),d;e.trace(`Could not download the file content for the object with guid ${u} due to an error.This may be due to broken file content on the server. Synchronization will continue and ignore this object`,d),a.push(u)}}))}return new Set(a)}class Ze{constructor(t,e){this.map={},t.forEach(([a,s])=>{const r=e(a)??e(s);r!==void 0&&(this.map[a]=[s,r])})}has(t){return this.map[t]!==void 0}get(t){return this.map[t]}getGuid(t){const e=this.get(t);if(e===void 0)return;const[a]=e;return a}getEntity(t){const e=this.get(t);if(e===void 0)return;const[,a]=e;return a}entries(){return Object.entries(this.map).map(([t,[e,a]])=>[t,e,a])}}async function Yt({dirtyMxObjects:n,syncedObjsOfflineToRuntimeMap:t,returnObjects:e,deletes:a={},extraGuidsToRetrieve:s=[],incompatibleObjectsJson:r=[],logger:c,database:i,fileBackend:u,offlineEntities:d}){c.trace(`Syncing of ${n.length} objects.`);const l=n.map(h=>t.mapMxObjectJSON(h.jsonData)),w=n.filter(h=>!K(t.map(h.getGuid())));c.trace(`Creating guids for ${w.length} offline objects.`);const O=new z,b=await async function(h,D){const B=h.reduce((m,f)=>{const x=f.getEntity();return m[x]=(m[x]??0)+1,m},{}),P={},L=[];let g=j();for(;Object.entries(g).length>0;){const m=await D(g);if(Object.keys(m.success).length===0&&m.failure.length===0)throw new et("create_guids API did not return a valid response");Object.entries(m.success).forEach(([f,x])=>{P[f]=(P[f]??[]).concat(x)}),L.push(...m.failure),g=j()}const M=new Ke;return h.filter(m=>!L.includes(m.getEntity())).forEach(m=>{const f=P[m.getEntity()].shift();M.add(m.getGuid(),f)}),M;function j(){return Object.entries(B).reduce((m,[f,x])=>{const _=P[f]?.length??0;return!L.includes(f)&&x>_&&(m[f]=x-(P[f]?.length??0)),m},{})}}(w,$e);c.trace(`Created guids for ${w.length} offline objects in ${O.measure()} milliseconds.`),O.reset(),await async function(h,D,B,P,L){if(D.some(m=>K(m.getGuid())))throw new et("Runtime objects are not expected here");const g=_t(D);await L.usingWriteTransaction(async m=>{await m.updateEntityGuids(D.map(f=>f.getGuid()),new Ze(B.entries(),f=>g[f]?.getEntity()),h),G.import(B.reverse())});const M=P.toAbsolutePath("documents"),j=D.filter(m=>it(m.jsonData)).map(m=>{const f=B.map(m.getGuid());return[M+"/"+J(m.getGuid(),""),M+"/"+J(f,""),f]});await q({moves:j},P)}(d,w,b,u,i),c.trace(`Updated offline guids with runtime guids in ${O.measure()} milliseconds.`);const y=l.map(h=>b.mapMxObjectJSON(h)),p=await Vt(y.map(h=>h.guid),i);c.trace("Uploading file documents."),O.reset();const v=await Promise.all(y.filter(h=>it(h)).concat(r.filter(h=>Te(h))).map(async h=>{c.trace(`Uploading file content of ${h.objectType} with guid ${h.guid}.`);const D=new z,B=await Qe(u,h);return c.trace(`Uploaded file content of ${h.objectType} with guid ${h.guid} in ${D.measure()} milliseconds.`),B}));c.trace(`Uploaded file documents in ${O.measure()} milliseconds.`);const S=y.map(h=>({guid:h.guid,syncId:p[h.guid],changes:De(h),...K(h.guid)?{}:{objectType:h.objectType}})),T=await Vt(r.map(h=>h.guid),i),E=r.map(h=>({guid:h.guid,objectType:h.objectType,syncId:T[h.guid],changes:xe(h)})),$=v.reduce((h,D)=>D.tempGuid?{...h,[D.tempGuid]:D.fileObjGuid}:h,{});c.trace("Syncing objects with runtime."),O.reset();const o=e?await Rt(S,$,!0,a,t.map(s)):await Rt(S,$,!1,a,[],E);return c.trace(`Synced objects with runtime in ${O.measure()} milliseconds.`),{response:o,createdGuidsMapping:b}}async function Vt(n,t){const e=await t.usingReadTransaction(a=>a.retrieveSyncIds(n));return Object.assign({},...e.map(([a,s])=>({[a]:s})))}async function Qt(n,t,e){const a=await n.increaseAndGetUniqueId(e);return Array.from({length:e},(s,r)=>{const c=Math.round(1e4*Math.random());return`${t}:${a-r}:${c}`})}async function Zt(n,t,e,a,s,r){if(n.length===0)return;const c=Lt(n,g=>g.getGuid()),i=G.reverse(),[u,d,l,w]=c.reduce(([g,M,j,m],f)=>{const x=!t.isNew(f.getGuid());x&&K(i.map(f.getGuid()))&&g.push(f),f.isPersistable()&&(M.push(f),x&&j.push(f));const _=f.getEntity();return at().hasOnlineSyncMode(f.getEntity())&&(m.has(_)?m.get(_).push(f.getGuid()):m.set(_,[f.getGuid()])),[g,M,j,m]},[[],[],[],new Map]);if(w.size>0){const g=["An attempt to delete object(s) configured with 'online' synchronization mode in an offline context.","Objects list:"];for(const[M,j]of w)g.push(`'${M}': ${j.join(", ")}`);throw new kt(g.join(`
`))}const O=i.map(u.flatMap(g=>g.isPersistable()&&!s.has(g.getEntity())?g.getGuid():[])),b=bt();await r.usingWriteTransaction(async g=>{await g.deleteEntitiesByGuid(l.map(m=>i.map(m.getGuid())));const M=await Qt(g,b.getSessionObjectId(),O.length);await g.insertTombstones(O.map((m,f)=>({guid:m,syncId:M[f]})));const j=yt(m=>zt(m,a,!1));return Promise.all(d.flatMap(m=>Object.entries(j(m.getEntity())??{}).map(([f,x])=>Promise.all(x.map(_=>g.updateEntityDataReferringTo(f,i.map(m.getGuid()),_,null))))))});const y=(g,M)=>Mt(g,i,e.toAbsolutePath((M?"thumbnails":"documents")+"/"));q({deletes:l.filter(({jsonData:g})=>it(g)).flatMap(({jsonData:g})=>Z(g.objectType)?[y(g,!1),y(g,!0)]:y(g,!1))},e).catch(tt);const p=c.map(g=>g.getGuid()),v=t.getAllObjects().filter(g=>!i.has(g.getGuid())&&!p.includes(g.getGuid())),S=ot(v.flatMap(g=>g.isPersistable()?[]:g.getEntity())),T=yt(g=>zt(g,[...a,...S],!0)),E=ot(c.map(g=>g.getEntity())),$=E.flatMap(g=>Object.values(T(g)??{})).flat(),o=v.flatMap(g=>{const M=$.flatMap(j=>{if(g.has(j)){const m=g.getReferences(j).filter(f=>p.includes(f));return!g.isReadonlyAttr(j)&&m.length>0?[[j,m]]:[]}return[]});return M.length>0?[[g,new Map(M)]]:[]}),h=o.map(([g,M])=>{const j=Bt(g.jsonData);return M.forEach((m,f)=>{const x=j.attributes[f].value;g.isObjectReferenceSet(f)&&Array.isArray(x)?j.attributes[f].value=x.filter(_=>!m.includes(_)):j.attributes[f].value=null}),j}),[D,B]=v.reduce(([g,M],j)=>{const m=j.getGuid();return Object.entries(t.getChanges(m)).filter(([f,x])=>$.includes(f)).forEach(([f,x])=>{const _=x.value;j.isObjectReferenceSet(f)||!p.includes(_)?Array.isArray(_)&&_.some(R=>p.includes(R))&&(_.length===1||_.every(R=>p.includes(R))?L(g,m,f):x.hash||function(R,U,A,N){R.has(U)||R.set(U,{}),I(R.get(U))[A]={value:N}}(M,m,f,_.filter(R=>!p.includes(R)))):L(g,m,f)}),[g,M]},[new Map,new Map]);t.onDelete(p),t.setMxObjects(h),t.removeChanges(Object.fromEntries(D)),t.addChanges(Object.fromEntries(B)),St(p.filter(ft)),u.forEach(g=>{const M=g.getGuid();i.has(M)&&G.remove(i.map(M))});const P=o.flatMap(([g,M])=>Array.from(M.keys()).map(j=>({guid:g.getGuid(),attr:j})));function L(g,M,j){g.has(M)||g.set(M,[]),I(g.get(M)).push(j)}await ct(...E.map(g=>({entity:g})),...P,...p.map(g=>({guid:g})))}function ta(n){return n.type==="push_to_client"}function $t(n){return n.filter(ta).flatMap(t=>t.args.guids)}async function te(n,t,e,a,s,r,c=new It,i="nothing"){const u=function(l){const w=new Set(l),O=[];return b=>b!==void 0&&(!!w.has(b)||(O.includes(b)||(O.push(b),Ct.get().getLogger(gt.Synchronization).warn(`Object of type ${b} cannot be pushed to client, skipping it.`)),!1))}(s),d=qt(e);await t.usingWriteTransaction(async l=>{if(n.length>0){const w=await l.retrieveMxObjectMetasByGuids(n),O=Object.assign({},...w.map(p=>({[p.guid]:p.objectType}))),b=[],y=[];if(n.forEach(p=>{const v=d[p],S=v?.objectType??O[p];S&&u(S)&&y.push(p),S&&u(v?.objectType)&&b.push(v)}),await l.deleteEntitiesByGuid(y),await l.insertMxObjects(b),i==="clean"&&b.length>0){const p=Object.values(b).map(v=>v.guid);await l.deleteTombstones(p)}}i==="reset"&&await l.truncateTombstones()}),n.filter(l=>!Object.prototype.hasOwnProperty.call(d,l)).forEach(l=>{let w=l;c.has(l)?w=c.map(l):r.has(l)&&(w=r.map(l));const O=a.getObject(w);O!==null&&O.markAsUnavailable()}),n.filter(l=>c.has(l)).forEach(l=>r.add(l,c.map(l))),St(n.map(l=>r.map(l)))}async function ee(n,t,e){const a=Xe(t,n),s=ot($t(n.instructions??[])),r=qt(n.objects??[]),[c,i]=V(b=>r[b]!==void 0,s),[u,d]=V(b=>K(b),i),l=Object.assign({},...c.map(b=>({[b]:r[b].objectType})),...u.map(b=>({[b]:pt(b)})),...await async function(b,y){if(y.length===0)return[];const p=G.reverse().map(y);return(await b.usingReadTransaction(v=>v.retrieveMxObjectMetasByGuids(p))).map(v=>({[G.map(v.guid)]:v.objectType}))}(e,d)),w=ot(a.filter(ea).map(b=>b.entity).concat(Object.values(l))).map(b=>({entity:b})),O=ot(a.filter(aa).map(b=>b.guid).concat(s)).filter(b=>t.has(b)).map(b=>({guid:b}));return[...a.filter(b=>"attr"in b&&!s.includes(b.guid)),...O,...w]}function ea(n){return"entity"in n}function aa(n){return"guid"in n&&!("attr"in n)}async function sa(n,t,e,a,s,r,c,i,u=[],d=!1){let l;try{const[y,p]=function([T,E]){const $=Object.fromEntries(Object.entries(T).filter(([h,D])=>wt(h))),o=E.filter(h=>wt(h.guid,h.objectType));return[$,o]}(Ce(a,n,Ge(t).concat(_e()))),v=function(T){return function(E,$){return E.map(o=>({...o,attributes:Object.fromEntries(Object.entries(o.attributes).filter(([h,D])=>$(o,h,D)))}))}(T,(E,$,o)=>!(E.hash===void 0&&o.readonly||ae(E.objectType,$,o.value)))}(p),S=function(T,E){return Object.fromEntries(Object.entries(E).flatMap(([o,h])=>{const D=$(o,h);return Object.keys(D).length>0?[[o,D]]:[]}));function $(o,h){const D=T.getObject(o)?.getEntity()??pt(o);return Object.fromEntries(Object.entries(h).filter(([B,P])=>!ae(D,B,P.value??null)))}}(a,y);l=d?await Pe(T=>Ft(n,t,S,v,u,T),10):await Ft(n,t,S,v,u)}catch(y){throw await async function(p,v,S){if(p instanceof Ae){const T=se(ce(p.original,G,v)),E=(await ee(T,v,S)).filter($=>!("attr"in $));await ct(...E),await Be(T.instructions),await ke(T.datavalidation)}}(y,a,r),y}const w=se(ce(l,G,a)),O=await ee(w,a,r);await async function(y,p,v,S,T){const E=new Set($t(y.instructions??[])),$=Array.from(E),o=y.objects?.filter(g=>E.has(g.guid))??[],h=$.filter(g=>rt(pt(g))),D=h.length===0?[]:await at().retrieveByGuids(h),{downloads:B,moves:P,deletes:L}=await Kt(D,o,!1,G,p);$.length!==0&&(await q({downloads:B},p),await te($,v,y.objects??[],S,T,G,new It,o.length!==0?"clean":"nothing"),await q({moves:P},p),q({deletes:L},p).catch(tt))}(l,c,r,a,e);const b=await Re(a,s,w,O,{targetForm:i});try{const y=w.actionResult;return y==null?void 0:Le(y.value,y.type,p=>I(a.getObject(p)))}finally{b()}}function ae(n,t,e){const a=H(n)?.attributes[t];return(a?.type==="ObjectReference"||a?.type==="ObjectReferenceSet")&&e!==null&&!function(s){return Array.isArray(s)?s.some(r=>K(r)):K(s)}(e)}function se({objects:n=[],changes:t={},resets:e={},deletes:a=[],newpersistable:s=[],commits:r=[],instructions:c=[],datavalidation:i=[],...u}){const d=new Set($t(c));function l(w,O){return d.has(w)||wt(w,O)}return{...u,deletes:Tt(a,l),newpersistable:Tt(s,l),commits:Tt(r,l),changes:ie(t,l),resets:ie(e,l),instructions:na(c),objects:n.filter(w=>l(w.guid,w.objectType)),datavalidation:ia(i,l)}}function wt(n,t){return K(n)&&ne(I(t??pt(n)))}function ne(n){return H(n)?.isPersistable===!1||at().hasOnlineSyncMode(n)}function Tt(n,t){return n.filter(e=>t(e))}function ie(n,t){return Object.assign({},...Object.keys(n).filter(e=>t(e)).map(e=>({[e]:n[e]})))}function na(n){return n.flatMap(t=>{switch(t.type){case"refresh_class":const e=t.args.classnames.filter(ne);return e.length>0?[{...t,args:{classnames:e}}]:[];case"refresh_object_list":const a=t.args.ObjectIds.filter(s=>wt(s));return a.length>0?[{...t,args:{ObjectIds:a}}]:[];default:return t}})}function ia(n,t){return n.filter(({guid:e})=>t(e))}function ce({actionResult:n,newpersistable:t=[],objects:e=[],changes:a={},commits:s=[],committedObjectsOmitted:r=!1,resets:c={},deletes:i=[],instructions:u=[],datavalidation:d=[]},l,w){return{actionResult:n,committedObjectsOmitted:r,newpersistable:t,commits:s,datavalidation:d,deletes:l.map(i),instructions:ra(u,l),objects:e.map(O=>l.mapMxObjectJSON(O)),changes:ca(a,e,w,l),resets:oa(c,l)}}function ca(n,t,e,a){return Object.assign({},...Object.entries(n).map(([s,r])=>{const c=(t.find(u=>u.guid===s)??I(e.getObject(a.map(s))).jsonData).objectType,i=H(c);return i?{[a.map(s)]:a.mapChange(r,i)}:{[s]:r}}))}function oa(n,t){return Object.assign({},...Object.keys(n).map(e=>({[t.map(e)]:n[e]})))}function ra(n,t){return n.map(e=>e.type==="push_to_client"?{...e,args:{guids:t.map(e.args.guids)}}:e)}async function ua(n,t,e,a,s,r,c,i=new Set){try{return await async function(u,d,l,{schema:w,preserveData:O,fetch:b,never:y,online:p},v,S,T,E){const $=S?{}:Object.fromEntries(Object.entries(v).filter(([m])=>O.includes(m)).map(([m,f])=>[m,f])),o=new z;E.trace("Fetching objects.");const h=await async function(m,f,x){return(await Promise.all([...m.map(({xpath:A})=>_(A)),R()])).flat();async function _(A){x.trace(`Fetching objects by XPath: ${A}`);const N=new z,F=await Fe(A);return x.trace(`Fetched ${F.objects?.length??0} objects by XPath ${A} in ${N.measure()} milliseconds.`),U(I(F.objects),I(F.resultGuids))}async function R(){const A=Object.values(f).flat();if(A.length===0)return[];x.trace(`Fetching ${A.length} preserved objects.`);const N=new z,F=await Ie(A,{});return x.trace(`Fetched  ${A.length===F.objects?.length?A.length:`${F.objects?.length??0} of ${A.length}`} preserved objects in ${N.measure()} milliseconds.`),Object.entries(f).flatMap(([,k])=>U(I(F.objects),k.filter(C=>F.resultGuids.includes(C))))}function U(A,N){const F=A.reduce((k,C)=>(k[C.guid]=C,k),{});return N.map(k=>F[k])}}(b,$,E);E.trace(`Fetched ${h.length} objects and completed in ${o.measure()}ms.`),E.trace("Calculating file operations.");const[D,B]=await async function(m,f,x,_,R){const U=R?[]:await async function(X,Q){if(Q.some(Ot=>!rt(Ot)))throw new et("Non-file document entity passed.");return X.usingReadTransaction(async Ot=>(await Promise.all(Q.map(ht=>Ot.retrieveMxObjects(ht,void 0,{attributes:[Ut.ChangedDate]})))).flat().map(ht=>[ht.guid,ht.attributes[Ut.ChangedDate]?.value]))}(f,_.filter(X=>rt(X))),A=x.toAbsolutePath("documents")+"/",N=U.map(([X,Q])=>A+J(X,Q??null)),F=x.toAbsolutePath("thumbnails")+"/",k=U.map(([X,Q])=>F+J(X,Q??null)),[C,W]=await oe(x,m,N,!1),[dt,jt]=await oe(x,m,k,!0);return[C.concat(dt),W.concat(jt)]}(h,u,d,O,S);E.trace(`${D.length} files to be downloaded, ${B.length} files to be removed`),E.trace("Downloading files."),o.reset();const P=await Xt(D,d,E),L=P.size>0?h.filter(m=>!P.has(m.guid)):h;E.trace(`Downloaded ${D.length-P.size} files in ${o.measure()} milliseconds.`),E.trace("Compute cached objects to update or delete."),o.reset();const[g,M]=function(m,f,x,_,R,U){const A=G.reverse(),N=m.getAllObjects().filter(C=>{if(!C.isPersistable()||m.isNew(C.getGuid())||_.includes(C.getEntity()))return!1;if(U||!x.includes(C.getEntity()))return!0;const W=R[C.getEntity()]??[];return G.map(W).includes(C.getGuid())}).map(C=>{const W=A.map(C.getGuid()),dt=f.find(jt=>jt.guid===W);return[dt?G.mapMxObjectJSON(dt):void 0,C]}),[F,k]=V(([C])=>C!==void 0,N);return[F.map(([C])=>C),k.map(([C,W])=>W.getGuid())]}(l,L,O,y,v,S);E.trace(`Compute cached objects to update or delete completed in ${o.measure()} milliseconds. ${g.length} objects will be updated, ${M.length} will be deleted.`),E.trace("Computing subscription updates."),o.measure();const j=function(m,f,x,_,R,U,A,N){const F=new Set([...f,...x]);return[...m.filter(k=>!(!N&&F.has(k))||R[k]!==void 0&&!R[k].every(C=>_.find(W=>W.guid===C)!==void 0)).map(k=>({entity:k})),...U.map(k=>({guid:k})),...A.map(k=>({guid:k}))]}(w,[...O,...y],p??[],L,$,g.map(m=>m.guid),M,S);return E.trace(`Computing subscription updates completed in ${o.measure()} milliseconds.`),E.trace("Rebuilding the database."),o.reset(),await async function(m,f,x,_,R,U,A=new Set){const N=new Set([...R,...U]),F=f.filter(C=>!N.has(C)),k=R.length===0;await m.usingWriteTransaction(async C=>{const W=[...F,...A];await C.dropEntityTables(W),k?(await C.reset(),await C.updateEntityMetadatas(bt().getOfflineMetadata())):await C.deleteEntitiesByGuid(Object.values(_).flat()),await C.ensureSchema(F,0),await C.insertMxObjects(x)})}(u,w,L,Object.fromEntries(Object.entries($).map(([m,f])=>[m,G.map(f)])),S?[]:[...O,...y],p??[],T),E.trace(`Rebuilding the database completed in ${o.measure()} milliseconds.`),E.trace(`Updating cache. ${g.length} to be updated, ${M.length} to be deleted.`),o.reset(),l.setMxObjects(g),l.onDelete(M),E.trace(`Updating cache completed in ${o.measure()} milliseconds.`),E.trace(`Removing ${B.length} files.`),o.reset(),Promise.all(B.map(m=>d.removeFile(m))).catch(tt),E.trace(`Removing ${B.length} files completed in ${o.measure()} milliseconds.`),j}(n,t,e,a,s,r,i,c)}catch(u){throw c.warn(u),new Ue}}async function oe(n,t,e,a){const s=n.toAbsolutePath(a?"thumbnails":"documents")+"/",r=t.filter(i=>it(i,a)).map(i=>{const u=i.attributes.changedDate?.value;return{sourceUrl:Nt(i.guid,u??null,a),downloadPath:s+J(i.guid,u??null),guid:i.guid}}),c=(await n.listDir(s)).map(i=>s+i);return[r.filter(i=>!c.includes(i.downloadPath)).map(({sourceUrl:i,downloadPath:u,guid:d})=>[i,u,d]),c.filter(i=>!r.find(u=>u.downloadPath===i)&&!e.includes(i))]}async function la(n,t,e,a,s,r,c){(function(){if(Lt(n,d=>d.getGuid()).length!==n.length)throw new et("Duplicate objects aren't allowed")})(),c.trace("Selective sync started.");const i=new z,u=await At(async()=>{const d=n.filter(j=>!a.isNew(j.getGuid())),l=d.length!==0,w=Object.keys(t).length!==0;if(!l&&!w)return c.trace("Nothing to sync."),[];c.trace(`Selective sync to sync ${n.length} objects and ${Object.keys(t).length} deletes.`);const O=d.map(j=>j.getGuid()),b=G.reverse(),y=d.filter(j=>ft(j.getGuid())),p=O.filter(j=>!ft(j));i.reset();const{createdGuidsMapping:v,response:S}=await Yt({dirtyMxObjects:y,syncedObjsOfflineToRuntimeMap:b,returnObjects:!0,deletes:t,extraGuidsToRetrieve:p,logger:c,database:s,fileBackend:r,offlineEntities:e});c.trace(`Selective sync synced changes with runtime in ${i.measure()} milliseconds.`);const T=G.reverse(),E=function(j){const m=new Set(j.map(f=>f.getEntity()));return j.map(f=>({guid:f.getGuid()})).concat(Array.from(m).map(f=>({entity:f})))}(d),$=yt(j=>rt(j)),o=d.filter(j=>$(j.getEntity())).map(j=>j.jsonData),{downloads:h,moves:D,deletes:B}=await Kt(o,S.objects,!0,G,r),P=await Xt(h,r,c),L=P.size===0?S.objects:S.objects.filter(j=>!P.has(j.guid));c.trace("Selective sync to update the local database."),i.reset(),await te(T.map(O),s,L,a,e,G,v.reverse(),w?"reset":"nothing"),c.trace(`Selective sync updated the local database in ${i.measure()} milliseconds.`);const g=P.size>0?D.filter(([j,m,f])=>!P.has(f)):D;await q({moves:g},r,c),q({deletes:B},r,c).catch(j=>tt(j));const M=L.flatMap(j=>a.has(G.map(j.guid))?G.mapMxObjectJSON(j):[]);return a.setMxObjects(M),E});u.length>0&&(c.trace("Selective sync to update UI with the latest state of the synchronized objects."),i.reset(),await ct(...u),c.trace(`Selective sync updated the UI with the latest state of the synchronized objects in ${i.measure()} milliseconds.`)),c.trace("Selective sync completed.")}class da{constructor(t,e,a,s,r,c=Ct.get()){this.syncConfig=t,this.objectCache=e,this.lockManager=a,this.fileBackend=s,this.database=r,this.startupLogger=c.getLogger(gt.Startup),this.syncLogger=c.getLogger(gt.Synchronization),this.selectiveSyncLogger=c.getLogger(gt.SelectiveSync),this.onlineEntities=new Set(t.online),function(){const i=he("login","logout","create_guids","synchronize_objects","retrieve_by_xpath","get_client_log_levels");function u(d){return d.init.method==="get"&&d.url.startsWith(`${mx.remoteUrl}file?`)}be(Ne(2,d=>i(d)||u(d)))}()}async initialize(t,e){e!==void 0&&await new Ve(this.database,e).apply();const a=this.syncConfig.schema.filter(i=>!this.hasOnlineSyncMode(i)),s=function(i){return i[i.length-1]?.version??0}(t),r=await this.database.usingWriteTransaction(async i=>(await i.ensureSchema(a,s),i.getDatabaseVersion()));if(s<=r)this.startupLogger.debug("The database schema is up-to-date.");else{const i=new z;await this.database.runMigrations(t),this.startupLogger.debug(`The app has upgraded the local database version from ${r} to ${s} in ${i.measure()} milliseconds.`)}const{dirtyObjects:c}=await this.retrieveDirtyObjects();Gt(c.map(i=>i.getGuid()))}async downloadObjects(t,e,a){this.syncLogger.trace("Downloading objects");const s=new z,r=ua(this.database,this.fileBackend,this.objectCache,this.syncConfig,t,e,this.syncLogger,a);return this.syncLogger.info(`Downloading objects completed in ${s.measure()} milliseconds.`),r}async cleanDatabase(){await this.database.delete(this.syncConfig.schema)}async create(t){const e=I(H(t)),a=e.isPersistable?ge():me(e);return this.objectCache.onCreate([a]),this.objectCache.setMxObjects([fe(a,e)]),this.objectCache.getObject(a)}async retrieve(t,e,a){const{jsons:s,count:r}=await this._retrieveJson(t,e,a);return this.objectCache.setMxObjects(s),{mxObjects:s.map(c=>I(this.objectCache.getObject(c.guid))),count:r}}async retrieveByGuids(t){return(await this.database.usingReadTransaction(e=>e.retrieveMxObjectByGuids(t))).map(e=>G.mapMxObjectJSON(e))}async retrieveUncached(t,e,a){const{jsons:s,count:r}=await this._retrieveJson(t,e,a);return{mxObjects:s.map(Et.fromJson),count:r}}async retrieveDirtyObjects(t=!1,e=new Set){const a=new Set(this.syncConfig.never),s=await this.database.usingReadTransaction(d=>d.retrieveDirtyObjects(a)),r=(d,l)=>{const w=d.has(l)?d.get(l)+1:1;d.set(l,w)},{dirtyObjects:c,incompatibleObjectsJson:i,incompatibleObjectsCount:u}=s.flat().reduce((d,l)=>{const w=l.objectType;if(e.has(w)||H(w)==null)return d.incompatibleObjectsJson.push(l),r(d.incompatibleObjectsCount,w),d;try{const O=t?G.mapMxObjectJSON(l):l;d.dirtyObjects.push(Et.fromJson(O))}catch{d.incompatibleObjectsJson.push(l),r(d.incompatibleObjectsCount,w)}return d},{dirtyObjects:[],incompatibleObjectsJson:[],incompatibleObjectsCount:new Map});return u.forEach((d,l)=>{this.syncLogger.warn(`Failed to parse ${d} object${d===1?"":"s"} of type '${l}'and to prevent data loss new 'System.SynchronizationError' corresponding to these failed objects will be created.`)}),{dirtyObjects:c,incompatibleObjectsJson:i}}async retrieveDeletes(){const t=await this.database.usingReadTransaction(e=>e.retrieveAllTombstones());return Object.fromEntries(t.map(e=>[e.guid,e.syncId]))}async insertOrReplace(t){const e=bt().getSessionObjectId();await this.database.usingWriteTransaction(async a=>{const s=G.reverse(),r=await Qt(a,e,t.length);return a.insertMxObjectsWithSyncId(t.map((c,i)=>({...s.mapMxObjectJSON(c),syncId:r[i]})))})}async executeMicroflow(t,e,a,s=[],r=!1){return sa(t,e,this.syncConfig.schema,this.objectCache,this.lockManager,this.database,this.fileBackend,a,s,r)}async upload(t=new Set){const{dirtyObjects:e,incompatibleObjectsJson:a}=await this.retrieveDirtyObjects(!1,t),s=await this.retrieveDeletes(),r=e.length!==0,c=Object.keys(s).length!==0,i=a.length!==0;if(!(r||c||i))return{};this.syncLogger.trace(`Uploading ${e.length} changes, ${Object.keys(s).length} deletes.`),e.length+Zt.length>1e3&&this.syncLogger.warn("Uploading excessive amount of data will slow down synchronization.");const u=new z,{createdGuidsMapping:d,response:l}=await Yt({returnObjects:!1,dirtyMxObjects:e,syncedObjsOfflineToRuntimeMap:G.reverse(),deletes:s,incompatibleObjectsJson:a,logger:this.syncLogger,database:this.database,fileBackend:this.fileBackend,offlineEntities:this.syncConfig.schema}),w=d.reverse();if(this.syncLogger.trace(`Synchronizing objects took ${u.measure()} milliseconds.`),!r)return await this.database.usingWriteTransaction(p=>p.truncateTombstones()),{};this.syncLogger.trace("Updating local database with uploaded changes."),u.reset();const O=_t(e);await this.database.usingWriteTransaction(async p=>[...await Promise.all(Object.entries(l.fileChangedDates).map(async([v,S])=>{const T=w.map(v),E=I(O[T]);return p.updateEntityData(E.getEntity(),v,"changedDate",S)})),await p.clearDirtyFlags(e.map(v=>d.map(v.getGuid()))),await(c?p.truncateTombstones():Promise.resolve())]),this.syncLogger.trace(`Updating local database took ${u.measure()} milliseconds.`),Pt();const b=Object.entries(l.fileChangedDates).map(([p,v])=>{const S=p,T=w.map(S),E=e.find(o=>o.getGuid()===T).jsonData,$=this.fileBackend.toAbsolutePath("documents/");return[$+J(S,I(E.attributes.changedDate).value),$+J(S,v),S]});this.syncLogger.trace("Executing file instructions for uploaded file documents."),u.reset(),await q({moves:b},this.fileBackend),this.syncLogger.trace(`Executing file instructions for uploaded file documents took ${u.measure()} milliseconds.`);const y=G.reverse();return e.reduce((p,v)=>{const S=v.getEntity();return p[S]=(p[S]??[]).concat(y.map(v.getGuid())),p},{})}async selectiveSync(t,e={}){return la(t,e,this.syncConfig.schema,this.objectCache,this.database,this.fileBackend,this.selectiveSyncLogger)}async delete(t){return Zt(t,this.objectCache,this.fileBackend,this.syncConfig.schema,new Set(this.syncConfig.never),this.database)}async clearFromClient(t){await async function(e,a,s,r){if(!I(H(e)).isPersistable)throw Error("Entity must be persistable");const c=await r.usingReadTransaction(y=>y.retrieveMxObjects(e)),i=G.reverse(),u=(y,p)=>Mt(y,i,s.toAbsolutePath((p?"thumbnails":"documents")+"/")),{deleteFilesInstructions:d,dbGuidsToClear:l}=c.reduce((y,p)=>{const{guid:v}=p;return y.dbGuidsToClear.push(v),it(p)&&(y.deleteFilesInstructions.push(u(p,!1)),Z(e)&&y.deleteFilesInstructions.push(u(p,!0))),y},{deleteFilesInstructions:[],dbGuidsToClear:[]});q({deletes:d},s).catch(tt),await r.usingWriteTransaction(y=>y.deleteEntitiesByEntity(e));const w=a.getAllObjects().filter(y=>y.getEntity()===e).map(y=>y.getGuid()),O=Array.from(new Set([...l,...w]));a.onDelete(O),St(O);const b=O.map(y=>({guid:y}));await ct({entity:e},...b)}(t,this.objectCache,this.fileBackend,this.database)}async executeDBModelSyncInstructions(t,e){if(t.length===0)return;const a=t.length>1;this.startupLogger.debug(`Found ${t.length} instruction${a?"s":""} to update the local database to the new schema.
${t.map(s=>`- ${s.getDescription()}`).join(`
`)}`),await this.database.usingWriteTransaction(async s=>{await Promise.all(t.map(r=>r.runTransaction(s))),await s.updateEntityMetadatas(e)}),await Promise.all(t.map(s=>s.postMigrate()))}deleteFiles(t){if(t.length===0)return;const e=this.fileBackend.toAbsolutePath("documents")+"/",a=this.fileBackend.toAbsolutePath("thumbnails")+"/";q({deletes:t.map(({guid:s,changedDate:r,isThumb:c})=>`${c?a:e}${J(s,r)}`)},this.fileBackend).catch(s=>tt(s))}async _retrieveJson(t,e,a){if(this.syncConfig.online?.includes(t))throw new et("Can not retrieve objects with online sync mode from offline database");const[s,r]=await this.database.usingReadTransaction(async c=>[await c.retrieveMxObjects(t,e,a),await c.retrieveMxObjectsCount(t,e)]);return{jsons:s.map(c=>G.mapMxObjectJSON(c)),count:r}}async retrieveOfflineMetadata(){return this.database.usingReadTransaction(t=>t.retrieveEntityMetadatas())}async runFullSynchronization(t=!1,e=new Set){const a=await At(async()=>{const s=await this.upload(e);return this.downloadObjects(s,t,e)});await ct(...a)}hasOnlineSyncMode(t){return this.onlineEntities.has(t)}}class ha extends pe{constructor(t,e,a,s){super(),this._store=e,this._getDocumentUrl=s||ba,this._objectCache=t,this._fileBackend=a}async getByGuid(t,e){const a=(await Promise.all(t.map(s=>this._getByGuid(s)))).filter(s=>s!=null);return this._objectCache.setMxObjects(a),{mxobjs:a.map(({guid:s})=>this._objectCache.getObject(s)),count:a.length}}async getByPath(t,e,a,s,r){const c=ye(e);if(s==="reverse"){const{cachedObjects:i}=we(t,s,e,this._objectCache),u=(H(a)?.isPersistable?await this._store.getByAttribute(a,c,mt(t)):[]).map(l=>G.mapMxObjectJSON(l)).filter(l=>Et.fromJson(l).getReferences(c).includes(t)).filter(l=>!i.some(w=>w.getGuid()===l.guid));this._objectCache.setMxObjects(u);const d=i.concat(u.map(l=>this._objectCache.getObject(l.guid)));return{mxobjs:d,count:d.length}}{let i=this._objectCache.getObject(t);if(!i){const{mxobjs:[b]}=await this.getByGuid([t]);b&&(i=b)}if(!i)return{mxobjs:[],count:0};const u=r===void 0?b=>this.getByGuid(b):r,{cachedObjects:d,uncachedGuids:l}=je(i,this._objectCache,c),{mxobjs:w}=await u(l),O=w.concat(d);return this._objectCache.setMxObjects(w.map(b=>b.jsonData)),{mxobjs:O,count:O.length}}}async commit(t,e){const a=Oe(t.map(b=>[b,Bt(this._objectCache.getChanges(b))])),[s,r]=V(b=>this._objectCache.has(b),t),c=s.map(b=>this._objectCache.getObject(b)),[i,u]=V(b=>b.isPersistable(),c),d=i.map(re),l=(await Promise.all(r.map(b=>this._getByGuid(b)))).concat(d).map(O);l.length>0&&(await at().insertOrReplace(l),Gt(l.map(b=>b.guid)),this._objectCache.setMxObjects(l));const w=u.map(re).map(O);return this._objectCache.setMxObjects(w),this._objectCache.onCommit(t),this._objectCache.removeChanges(function(b){const y={};return Object.keys(b).forEach(p=>{y[p]=Object.keys(b[p])}),y}(a)),{commits:t};function O(b){const y=a[b.guid];return{guid:b.guid,objectType:b.objectType,attributes:ve(Object.assign({},y,b.attributes),(p,v)=>Object.assign({},p,{value:y.hasOwnProperty(v)?y[v].value:p.value}))}}}rollback(t){this._objectCache.removeAllChanges(t);const e=t.filter(a=>this._objectCache.isNew(a));return this._objectCache.onDelete(e),Promise.resolve({deletes:e})}validate(t){return Promise.resolve({})}async saveDocument(t,e,a,s){if(s.size/1048576>a.maxFileSize)throw new kt("File too large");const r=await this._getByGuid(t),c=J(mt(t),r?r.attributes.changedDate?.value:void 0);await this._fileBackend.storeFile(s,this._fileBackend.toAbsolutePath("documents/"+c)),this._objectCache.makeChange(t,"HasContents",!0),e&&this._objectCache.makeChange(t,"Name",e),await this.commit([t],null)}getDocumentUrl(t,e,a,s){return this._getDocumentUrl(J(mt(t),e),e,a)}getImageUrl(t){return Promise.resolve(t)}async cleanup(){await at().cleanDatabase(),await this._fileBackend.removeDir(this._fileBackend.toAbsolutePath("documents")),await this._fileBackend.removeDir(this._fileBackend.toAbsolutePath("thumbnails")),Pt()}async remove(t){const{mxobjs:e}=await this.getByGuid(t);await at().delete(e)}_getByGuid(t){return Ee(t,async()=>{const e=await this._store.getByGuid(mt(t));return e===null?null:G.mapMxObjectJSON(e)})}}function re(n){return n.jsonData}function ba(n,t,e){var a="files/"+(e?"thumbnails":"documents");return`filesystem:${window.mx.appUrl}temporary/${a}/${n}?${Date.now()}`}class ga{constructor(t){this._database=t}async getByGuid(t){const e=await this._database.usingReadTransaction(a=>a.retrieveMxObjectByGuids([t]));return e.length>0?e[0]:null}getByAttribute(t,e,a){return this._database.usingReadTransaction(s=>{if(e==="guid")return s.retrieveMxObjectByGuids([a]);const r=H(t)?.attributes[e]?.type??"String";return s.retrieveMxObjects(t,{type:"function",name:"=",parameters:[{type:"attribute",attribute:e,attributeType:r},{type:"value",value:a,isGuid:Je(r)}]})})}}async function ma(n,t,e,a,s,r,c,i){const u=new da(a,n,t,s,e,r);await u.initialize(Ye,i);const d=new ga(e);return{dataBackend:new ha(n,d,s,c),offlineData:u}}export{ma as buildOfflineDataBackend};
